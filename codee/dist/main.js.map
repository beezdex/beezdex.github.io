{"version":3,"file":"main.js","mappings":"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","sources":["webpack://@standardnotes/classic-code-editor/./src/main.js"],"sourcesContent":["CodeMirror.modeURL = \"dist/codemirror/mode/%N/%N.js\";\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  const modeByModeMode = CodeMirror.modeInfo.reduce(function (acc, m) {\n    if (acc[m.mode]) {\n      acc[m.mode].push(m)\n    } else {\n      acc[m.mode] = [m]\n    }\n    return acc\n  }, {})\n\n  const modeModeAndMimeByName = CodeMirror.modeInfo.reduce(function (acc, m) {\n    acc[m.name] = { mode: m.mode, mime: m.mime }\n    return acc\n  }, {})\n\n  const modes = Object.keys(modeModeAndMimeByName)\n\n  let componentRelay\n  let workingNote, clientData\n  let lastValue, lastUUID\n  let editor, select\n  let ignoreTextChange = false\n  let initialLoad = true\n\n  function loadComponentRelay() {\n    componentRelay = new ComponentRelay({\n      targetWindow: window,\n      onReady: () => {\n        const platform = componentRelay.platform\n        if (platform) {\n          document.body.classList.add(platform)\n        }\n        loadEditor()\n      },\n      handleRequestForContentHeight: () => {\n        const baseHeight = 50\n        const scrollHeight = document.getElementsByClassName('CodeMirror-code')[0]?.scrollHeight\n        return baseHeight + scrollHeight\n      },\n    })\n\n    componentRelay.streamContextItem((note) => {\n      onReceivedNote(note)\n    })\n  }\n\n  function saveNote() {\n    if (workingNote) {\n      // Be sure to capture this object as a variable, as this.note may be reassigned in `streamContextItem`, so by the time\n      // you modify it in the presave block, it may not be the same object anymore, so the presave values will not be applied to\n      // the right object, and it will save incorrectly.\n      let note = workingNote\n\n      componentRelay.saveItemWithPresave(note, () => {\n        lastValue = editor.getValue()\n        note.content.text = lastValue\n        note.clientData = clientData\n\n        note.content.preview_plain = null\n        note.content.preview_html = null\n      })\n    }\n  }\n\n  function onReceivedNote(note) {\n    if (note.uuid !== lastUUID) {\n      // Note changed, reset last values\n      lastValue = null\n      initialLoad = true\n      lastUUID = note.uuid\n    }\n\n    workingNote = note\n    // Only update UI on non-metadata updates.\n    if (note.isMetadataUpdate) {\n      return\n    }\n\n    clientData = note.clientData\n    let mode = clientData.mode\n\n    if (!mode) {\n      // Assign editor's default mode from component settings\n      mode = componentRelay.getComponentDataValueForKey('language') ?? 'JavaScript'\n    }\n\n    changeMode(mode)\n\n    if (editor) {\n      if (note.content.text !== lastValue) {\n        ignoreTextChange = true\n        editor.getDoc().setValue(workingNote.content.text)\n        ignoreTextChange = false\n      }\n\n      if (initialLoad) {\n        initialLoad = false\n        editor.getDoc().clearHistory()\n      }\n\n      editor.setOption('spellcheck', workingNote.content.spellcheck)\n    }\n  }\n\n  function loadEditor() {\n    // Handler for the save command that is mapped to the :w (write) Vim key binding.\n    CodeMirror.commands.save = function () {\n      saveNote()\n    }\n    editor = CodeMirror.fromTextArea(document.getElementById('code'), {\n      extraKeys: {\n        'Alt-F': 'findPersistent',\n      },\n      lineNumbers: true,\n      styleSelectedText: true,\n      lineWrapping: true,\n      inputStyle: getInputStyleForEnvironment(),\n    })\n    editor.setSize('100%', '100%')\n\n    createSelectElements()\n\n    editor.on('change', function () {\n      if (ignoreTextChange) {\n        return\n      }\n      saveNote()\n    })\n\n    /**\n     * Scrolls the cursor into view, so the soft keyboard on mobile devices\n     * doesn't overlap the cursor. A short delay is added to prevent scrolling\n     * before the keyboard is shown.\n     */\n    const scrollCursorIntoView = (editor) => {\n      setTimeout(() => editor.scrollIntoView(), 200)\n    }\n\n    editor.on('cursorActivity', function (editor) {\n      if (componentRelay.environment !== 'mobile') {\n        return\n      }\n      scrollCursorIntoView(editor)\n    })\n\n    const initialKeyMap = componentRelay.getComponentDataValueForKey('keyMap') ?? 'default'\n    window.setKeyMap(initialKeyMap)\n  }\n\n  function createSelectElements() {\n    select = document.getElementById('language-select')\n    for (let index = 0; index < modes.length; index++) {\n      const option = document.createElement('option')\n      option.value = index\n      option.innerHTML = modes[index]\n      select.appendChild(option)\n    }\n  }\n\n  // Editor Modes\n  window.setKeyMap = function (keymap) {\n    editor.setOption('keyMap', keymap)\n    updateVimStatus(keymap)\n  }\n\n  function onLanguageSelect() {\n    const language = modes[select.selectedIndex]\n    changeMode(language)\n    saveNote()\n  }\n\n  document.getElementById('language-select').addEventListener('change', onLanguageSelect)\n\n  function setDefaultLanguage() {\n    const language = modes[select.selectedIndex]\n\n    // assign default language for this editor when entering notes\n    componentRelay.setComponentDataValueForKey('language', language)\n\n    // show a confirmation message\n    const message = document.getElementById('default-label')\n    const original = message.innerHTML\n    message.innerHTML = 'Success'\n    message.classList.add('success')\n\n    setTimeout(function () {\n      message.classList.remove('success')\n      message.innerHTML = original\n    }, 750)\n  }\n\n  document.getElementById('default-label').addEventListener('click', setDefaultLanguage)\n\n  function inputModeToMode(inputMode) {\n    const convertCodeMirrorMode = function (codeMirrorMode) {\n      if (codeMirrorMode) {\n        return {\n          name: codeMirrorMode.name,\n          mode: codeMirrorMode.mode,\n          mime: codeMirrorMode.mime,\n        }\n      } else {\n        return null\n      }\n    }\n\n    const extension = /.+\\.([^.]+)$/.exec(inputMode)\n    const mime = /\\//.test(inputMode)\n\n    if (extension) {\n      return convertCodeMirrorMode(CodeMirror.findModeByExtension(extension[1]))\n    } else if (mime) {\n      return convertCodeMirrorMode(CodeMirror.findModeByMIME(mime[1]))\n    } else if (modeModeAndMimeByName[inputMode]) {\n      return {\n        name: inputMode,\n        mode: modeModeAndMimeByName[inputMode].mode,\n        mime: modeModeAndMimeByName[inputMode].mime,\n      }\n    } else if (modeByModeMode[inputMode]) {\n      const firstMode = modeByModeMode[inputMode][0]\n      return {\n        name: firstMode.name,\n        mode: firstMode.mode,\n        mime: firstMode.mime,\n      }\n    } else {\n      return {\n        name: inputMode,\n        mode: inputMode,\n        mime: inputMode,\n      }\n    }\n  }\n\n  function changeMode(inputMode) {\n    if (!inputMode) {\n      return\n    }\n\n    const mode = inputModeToMode(inputMode)\n\n    if (mode) {\n      editor.setOption('mode', mode.mime)\n      CodeMirror.autoLoadMode(editor, mode.mode)\n      if (clientData) {\n        clientData.mode = mode.name\n      }\n      document.getElementById('language-select').selectedIndex = modes.indexOf(mode.name)\n    } else {\n      console.error('Could not find a mode corresponding to ' + inputMode)\n    }\n  }\n\n  function updateVimStatus(keyMap) {\n    const toggleButton = document.getElementById('toggle-vim-mode-button')\n\n    const newAction = keyMap === 'vim' ? 'Disable' : 'Enable'\n    const buttonClass = keyMap === 'vim' ? 'danger' : 'success'\n\n    toggleButton.innerHTML = `${newAction} Vim mode`\n    toggleButton.classList.remove('danger')\n    toggleButton.classList.remove('success')\n    toggleButton.classList.add(buttonClass)\n  }\n\n  function toggleVimMode() {\n    let newKeyMap\n\n    const currentKeyMap = componentRelay.getComponentDataValueForKey('keyMap') ?? 'default'\n    if (currentKeyMap === 'default') {\n      newKeyMap = 'vim'\n    } else {\n      newKeyMap = 'default'\n    }\n\n    window.setKeyMap(newKeyMap)\n    componentRelay.setComponentDataValueForKey('keyMap', newKeyMap)\n  }\n\n  document.getElementById('toggle-vim-mode-button').addEventListener('click', toggleVimMode)\n\n  function getInputStyleForEnvironment() {\n    const environment = componentRelay.environment ?? 'web'\n    return environment === 'mobile' ? 'textarea' : 'contenteditable'\n  }\n\n  loadComponentRelay()\n})\n"],"names":["CodeMirror","modeURL","document","addEventListener","modeByModeMode","modeInfo","reduce","acc","m","mode","push","modeModeAndMimeByName","name","mime","modes","Object","keys","componentRelay","workingNote","clientData","lastValue","lastUUID","editor","select","ignoreTextChange","initialLoad","saveNote","note","saveItemWithPresave","getValue","content","text","preview_plain","preview_html","changeMode","inputMode","convertCodeMirrorMode","codeMirrorMode","extension","exec","test","findModeByExtension","findModeByMIME","firstMode","inputModeToMode","setOption","autoLoadMode","getElementById","selectedIndex","indexOf","console","error","window","setKeyMap","keymap","keyMap","toggleButton","newAction","buttonClass","innerHTML","classList","remove","add","updateVimStatus","language","setComponentDataValueForKey","message","original","setTimeout","newKeyMap","getComponentDataValueForKey","ComponentRelay","targetWindow","onReady","platform","body","commands","save","fromTextArea","extraKeys","lineNumbers","styleSelectedText","lineWrapping","inputStyle","environment","setSize","index","length","option","createElement","value","appendChild","createSelectElements","on","scrollIntoView","scrollCursorIntoView","initialKeyMap","loadEditor","handleRequestForContentHeight","scrollHeight","getElementsByClassName","streamContextItem","uuid","isMetadataUpdate","getDoc","setValue","clearHistory","spellcheck","onReceivedNote"],"sourceRoot":""}